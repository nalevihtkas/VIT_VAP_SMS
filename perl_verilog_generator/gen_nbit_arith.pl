#!/usr/bin/env perl
use strict;
use warnings;
use feature 'say';

# Usage:
#   ./gen_nbit_arith.pl <N> <mode>
# Modes: add | sub_rc | sub_rb
# If args are missing, script will prompt interactively.

my $n = shift;
my $mode = shift;

if (!defined $n) {
    print "Enter bit-width N (>=1): ";
    chomp($n = <STDIN>);
}
if (!defined $mode) {
    print "Choose mode (add | sub_rc | sub_rb) : ";
    chomp($mode = <STDIN>);
}

die "Error: N must be a positive integer\n" unless defined $n && $n =~ /^\d+$/ && $n >= 1;
die "Error: mode must be one of: add, sub_rc, sub_rb\n" unless $mode =~ /^(add|sub_rc|sub_rb)$/;

my $tag = ($mode eq 'add') ? "adder" : ($mode eq 'sub_rc') ? "sub_rc_subtractor" : "sub_rb_subtractor";
my $vfile = "nbit_${tag}_${n}bit.v";
my $tbfile = "nbit_${tag}_${n}bit_tb.v";
my $module = "${tag}_${n}bit";

open my $vf, ">", $vfile or die "Can't open $vfile: $!\n";

print $vf <<"TOP";
`timescale 1ns/1ps
// Generated by gen_nbit_arith.pl
// Mode: $mode
// $n-bit module: $module

TOP

# Always emit fulladder
print $vf <<"FA";
module fulladder (
    input  wire a,
    input  wire b,
    input  wire cin,
    output wire sum,
    output wire cout
);
    // simple combinational full adder using arithmetic expression
    assign {cout, sum} = a + b + cin;
endmodule

FA

# If ripple borrow subtractor needed, emit fullsubtractor
if ($mode eq 'sub_rb') {
    print $vf <<"FS";
module fullsubtractor (
    input  wire a,
    input  wire b,
    input  wire bin,
    output wire diff,
    output wire bout
);
    // diff = a - b - bin  => diff = a ^ b ^ bin
    assign diff = a ^ b ^ bin;
    // borrow-out formula
    // bout = (~a & b) | ((~(a ^ b)) & bin)
    assign bout = (~a & b) | ((~(a ^ b)) & bin);
endmodule

FS
}

# Emit top-level module depending on mode
if ($mode eq 'add') {
    print $vf <<"MOD";
module $module (
    input  wire [${n}-1:0] a,
    input  wire [${n}-1:0] b,
    input  wire           cin,
    output wire [${n}-1:0] sum,
    output wire           cout
);
    wire [${n}-1:0] carry;

MOD

    for my $i (0..$n-1) {
        my $in_cin = ($i==0) ? "cin" : "carry[".($i-1)."]";
        print $vf <<"INST";
    // bit $i
    fulladder fa$i (
        .a(a[$i]),
        .b(b[$i]),
        .cin($in_cin),
        .sum(sum[$i]),
        .cout(carry[$i])
    );

INST
    }
    print $vf <<"ENDMOD";
    assign cout = carry[${n}-1];
endmodule

ENDMOD

} elsif ($mode eq 'sub_rc') {
    # ripple carry subtractor via two's complement: a - b = a + (~b) + 1
    print $vf <<"MOD";
module $module (
    input  wire [${n}-1:0] a,
    input  wire [${n}-1:0] b,
    input  wire           bin,   // borrow-in interpreted as initial borrow (0 or 1)
    output wire [${n}-1:0] diff,
    output wire           borrow   // borrow-out: 1 means a<b
);
    // implement a - b - bin  as a + (~b) + (1 - bin)
    // We'll compute a + (~b) + carry_in, where carry_in = 1 - bin
    wire [${n}-1:0] carry;
    wire carry_in = (bin ? 1'b0 : 1'b1); // if bin=0 => add 1; if bin=1 => add 0

MOD

    for my $i (0..$n-1) {
        my $in_cin = ($i==0) ? "carry_in" : "carry[".($i-1)."]";
        print $vf <<"INST";
    // bit $i : sum of a[i] + ~b[i] + carry
    fulladder fa$i (
        .a(a[$i]),
        .b(~b[$i]),
        .cin($in_cin),
        .sum(diff[$i]),
        .cout(carry[$i])
    );

INST
    }
    # When using two's complement, a - b - bin has borrow if final carry_out == 0
    print $vf <<"ENDMOD";
    assign borrow = ~carry[${n}-1];
endmodule

ENDMOD

} elsif ($mode eq 'sub_rb') {
    print $vf <<"MOD";
module $module (
    input  wire [${n}-1:0] a,
    input  wire [${n}-1:0] b,
    input  wire           bin,
    output wire [${n}-1:0] diff,
    output wire           bout
);
    wire [${n}-1:0] borrow;

MOD

    for my $i (0..$n-1) {
        my $in_bin = ($i==0) ? "bin" : "borrow[".($i-1)."]";
        print $vf <<"INST";
    // bit $i
    fullsubtractor fs$i (
        .a(a[$i]),
        .b(b[$i]),
        .bin($in_bin),
        .diff(diff[$i]),
        .bout(borrow[$i])
    );

INST
    }
    print $vf <<"ENDMOD";
    assign bout = borrow[${n}-1];
endmodule

ENDMOD
}

close $vf;
say "Wrote $vfile";

# Testbench generation
open my $tb, ">", $tbfile or die "Can't open $tbfile: $!\n";

print $tb <<"TBTOP";
`timescale 1ns/1ps
// Testbench for $module
module ${module}_tb;
    reg  [${n}-1:0] a;
    reg  [${n}-1:0] b;
    reg             inbin;
    wire [${n}-1:0] out;
    wire            bout_or_cout;

    $module dut (
        .a(a),
        .b(b),
        .bin(inbin),
        .diff(out),
        .bout(bout_or_cout)
    );

    reg [${n}:0] expected;
    integer i;
    integer errors;

    initial begin
        errors = 0;
        \$dumpfile("${module}.vcd");
        \$dumpvars(0, ${module}_tb);
TBTOP

if ($mode eq 'add') {
    print $tb "        for (i = 0; i < 200; i = i + 1) begin\n";
    print $tb "            a = \$random; b = \$random; inbin = \$random & 1; #5;\n";
    print $tb "            expected = a + b + inbin; #5;\n";
    print $tb "            if ({bout_or_cout,out} !== expected) errors = errors + 1;\n";
    print $tb "        end\n";
} else {
    print $tb "        for (i = 0; i < 200; i = i + 1) begin\n";
    print $tb "            a = \$random; b = \$random; inbin = \$random & 1; #5;\n";
    print $tb "            expected = a - b - inbin; #5;\n";
    print $tb "            if ({bout_or_cout,out} !== expected) errors = errors + 1;\n";
    print $tb "        end\n";
}

print $tb <<"TBEND";
        if (errors == 0) \$display("All tests passed for $module (N=$n, mode=$mode)!");
        else \$display("TEST FINISHED: %0d mismatches detected.", errors);
        #10; \$finish;
    end
endmodule
TBEND

close $tb;
say "Wrote $tbfile";
